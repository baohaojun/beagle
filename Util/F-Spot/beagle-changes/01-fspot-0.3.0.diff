From: Debajyoti Bera <dbera.web@gmail.com>

Local changes to F-Spot source files to make them work in beagle.
These changes are with respect to files included with F-Spot-0.3.0

--- /usr/share/devel/f-spot-0.3.0/src/Bim.cs	2006-11-16 09:33:33.000000000 -0500
+++ Bim.cs	2006-12-22 14:54:02.820000000 -0500
@@ -1,4 +1,33 @@
-namespace FSpot.Bim {
+//
+// Bim.cs
+//
+// Authors:
+//     Larry Ewing <lewing@novell.com>
+//
+//
+// Copyright (C) 2004 - 2006 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+namespace Beagle.Util.Bim {
 	public enum EntryType : ushort {
 		ObsoleteImageInfo = 0x03e8,  
 		MacPrintManager = 0x03e9,
@@ -86,7 +115,7 @@ namespace FSpot.Bim {
 			if (System.Text.Encoding.ASCII.GetString (header, 0, 4) != Marker)
 				throw new System.Exception ("missing header");
 			
-			Type = FSpot.BitConverter.ToUInt16 (header, 4, false);
+			Type = BitConverter.ToUInt16 (header, 4, false);
 
 		        int name_length = stream.ReadByte ();
 			if (name_length > 0) {
@@ -99,7 +128,7 @@ namespace FSpot.Bim {
 				stream.ReadByte ();
 
 			stream.Read (header, 0, 4);
-			uint length = FSpot.BitConverter.ToUInt32 (header, 0, false);
+			uint length = BitConverter.ToUInt32 (header, 0, false);
 
 			Data = new byte [length];
 			stream.Read (Data, 0, Data.Length);
@@ -115,7 +144,7 @@ namespace FSpot.Bim {
 			byte [] tmp;
 			tmp = System.Text.Encoding.ASCII.GetBytes (Marker);
 			stream.Write (tmp, 0, tmp.Length);
-			tmp = FSpot.BitConverter.GetBytes (Type, false);
+			tmp = BitConverter.GetBytes (Type, false);
 			stream.Write (tmp, 0, tmp.Length);
 
 			// Write the name
@@ -128,7 +157,7 @@ namespace FSpot.Bim {
 				stream.WriteByte (0);
 
 			// Write the data
-			tmp  = FSpot.BitConverter.GetBytes ((uint)Data.Length, false);
+			tmp  = BitConverter.GetBytes ((uint)Data.Length, false);
 			stream.Write (tmp, 0, tmp.Length);
 
 			stream.Write (Data, 0, Data.Length);
@@ -160,12 +189,12 @@ namespace FSpot.Bim {
 				switch (type) {
 				case EntryType.IPTCNAA:
 					System.IO.Stream iptcstream = new System.IO.MemoryStream (e.Data);
-					FSpot.Iptc.IptcFile iptc = new FSpot.Iptc.IptcFile (iptcstream);
+					Iptc.IptcFile iptc = new Iptc.IptcFile (iptcstream);
 					iptc.Select (sink);
 					break;
 				case EntryType.XMP:
 					System.IO.Stream xmpstream = new System.IO.MemoryStream (e.Data);
-					FSpot.Xmp.XmpFile xmp = new FSpot.Xmp.XmpFile (xmpstream);
+					Xmp.XmpFile xmp = new Xmp.XmpFile (xmpstream);
 					xmp.Select (sink);
 					break;
 				default:
--- /usr/share/devel/f-spot-0.3.0/src/BitConverter.cs	2005-10-25 13:54:27.000000000 -0400
+++ BitConverter.cs	2006-12-22 14:54:19.610000000 -0500
@@ -1,7 +1,36 @@
+//
+// BitConverter.cs
+//
+// Authors:
+//     Larry Ewing <lewing@novell.com>
+//
+//
+// Copyright (C) 2004 - 2006 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
 using System;
 using System.Runtime.InteropServices;
 
-namespace FSpot {
+namespace Beagle.Util {
 	public class BitConverter {
 		public static uint Swap (uint val, bool little) 
 		{
--- /usr/share/devel/f-spot-0.3.0/src/Exif.cs	2006-11-16 18:17:52.000000000 -0500
+++ Exif.cs	2006-12-22 14:55:28.300000000 -0500
@@ -8,6 +8,26 @@
 //
 // (C) 2002, 2004, 2005 Novell, Inc.
 //
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
 
 using System;
 using System.Collections;
@@ -15,8 +35,8 @@ using System.Runtime.InteropServices;
 
 using Mono.Unix;
 
-namespace Exif {
-	public enum Tag {
+namespace Beagle.Util.Exif {
+	public enum ExifTag {
 		InteroperabilityIndex		= 0x0001,
 		InteroperabilityVersion	        = 0x0002,
 		ImageWidth 			= 0x0100,
@@ -156,16 +176,16 @@ namespace Exif {
 		Count
 	}
 	
-	internal class ExifUtil {
+	public class ExifUtil {
 		
 		[DllImport ("libexif.dll")]
-		static extern IntPtr exif_tag_get_name (Tag tag);
+		static extern IntPtr exif_tag_get_name (ExifTag tag);
 		
 		[DllImport ("libexif.dll")]
-		static extern IntPtr exif_tag_get_title (Tag tag);
+		static extern IntPtr exif_tag_get_title (ExifTag tag);
 		
 		[DllImport ("libexif.dll")]
-		static extern IntPtr exif_tag_get_description (Tag tag);
+		static extern IntPtr exif_tag_get_description (ExifTag tag);
 		
 		[DllImport ("libexif.dll")]
 		static extern IntPtr exif_byte_order_get_name (ByteOrder order);
@@ -179,20 +199,20 @@ namespace Exif {
 		[DllImport ("libexif.dll")]
 		static extern IntPtr exif_ifd_get_name (Ifd ifd);
 		
-		public static string GetTagName (Tag tag)
+		public static string GetTagName (ExifTag tag)
 		{
 			
 			IntPtr raw_ret = exif_tag_get_name (tag);
 			return Marshal.PtrToStringAnsi (raw_ret);
 		}
 		
-		public static string GetTagTitle (Tag tag)
+		public static string GetTagTitle (ExifTag tag)
 		{
 			IntPtr raw_ret = exif_tag_get_title (tag);
 			return Marshal.PtrToStringAnsi (raw_ret);
 		}
 		
-		public static string GetTagDescription (Tag tag)
+		public static string GetTagDescription (ExifTag tag)
 		{
 			IntPtr raw_ret = exif_tag_get_description (tag);
 			return Marshal.PtrToStringAnsi (raw_ret);
@@ -326,7 +346,7 @@ namespace Exif {
 		[DllImport ("libexif.dll")]
 		internal static extern void exif_content_add_entry (HandleRef content, HandleRef entry);
 		
-		public ExifEntry Lookup (Tag tag)
+		public ExifEntry Lookup (ExifTag tag)
 		{
 			Assemble ();
 			
@@ -346,7 +366,7 @@ namespace Exif {
 			return entries.Contains (entry);
 		}
 
-		public ExifEntry GetEntry (Tag tag)
+		public ExifEntry GetEntry (ExifTag tag)
 		{
 			Assemble ();
 			
@@ -414,7 +434,7 @@ namespace Exif {
 	
 	[StructLayout(LayoutKind.Sequential)]
 	internal struct _ExifEntry {
-		public Tag tag;
+		public ExifTag tag;
 		public int format;
 		public uint components;
 		public IntPtr data;
@@ -463,16 +483,16 @@ namespace Exif {
 		internal static extern IntPtr exif_entry_new ();
 
 		[DllImport ("libexif.dll")]
-		internal static extern void exif_entry_initialize (HandleRef handle, Tag tag);
+		internal static extern void exif_entry_initialize (HandleRef handle, ExifTag tag);
 
-		public ExifEntry (ExifContent parent, Tag tag)
+		public ExifEntry (ExifContent parent, ExifTag tag)
 		{
 			handle = new HandleRef (this, exif_entry_new ());
 			parent.Add (this);
 			this.Reset (tag);
 		}
 		
-		public void Reset (Tag tag)
+		public void Reset (ExifTag tag)
 		{
 			unsafe {
 				// Free any exsting data so that _initialize will actually set the data
@@ -484,9 +504,9 @@ namespace Exif {
 			exif_entry_initialize (handle, tag);
 
 			//FIXME the month string in time fields in libexif ix currently broken so we do our own. 
-			if (tag == Tag.DateTime
-			    || tag == Tag.DateTimeOriginal
-			    || tag == Tag.DateTimeDigitized)
+			if (tag == ExifTag.DateTime
+			    || tag == ExifTag.DateTimeOriginal
+			    || tag == ExifTag.DateTimeDigitized)
 				this.SetData (System.DateTime.Now);
 
 		}
@@ -508,7 +528,7 @@ namespace Exif {
 			}
 		}
 		
-		public Tag Tag {
+		public ExifTag Tag {
 			get {
 				unsafe {
 					return _handle->tag;
@@ -563,12 +583,12 @@ namespace Exif {
 
 		public void SetData (uint s)
 		{
-			this.SetData (FSpot.BitConverter.GetBytes (s, this.ByteOrder == ByteOrder.Intel), 4);
+			this.SetData (BitConverter.GetBytes (s, this.ByteOrder == ByteOrder.Intel), 4);
 		}
 
 		public void SetData (ushort s)
 		{
-			this.SetData (FSpot.BitConverter.GetBytes (s, this.ByteOrder == ByteOrder.Intel), 2);
+			this.SetData (BitConverter.GetBytes (s, this.ByteOrder == ByteOrder.Intel), 2);
 		}	    
 
 		public void SetData (string value)
@@ -852,7 +872,7 @@ namespace Exif {
 			ifds.Add (new ExifContent (this, content));
 		}
 		
-		public ExifEntry LookupFirst (Tag tag)
+		public ExifEntry LookupFirst (ExifTag tag)
 		{
 			Assemble ();
 			foreach (ExifContent content in ifds) {
@@ -866,7 +886,7 @@ namespace Exif {
 			return null;
 		}
 
-		public string LookupFirstValue (Tag tag)
+		public string LookupFirstValue (ExifTag tag)
 		{
 			ExifEntry entry = LookupFirst (tag);
 			if (entry != null) {
--- /usr/share/devel/f-spot-0.3.0/src/IptcFile.cs	2006-11-16 17:33:45.000000000 -0500
+++ IptcFile.cs	2006-12-22 14:56:40.650000000 -0500
@@ -1,7 +1,37 @@
+//
+// Iptc.cs
+//
+// Authors:
+//     Larry Ewing <lewing@novell.com>
+//
+//
+// Copyright (C) 2004 - 2006 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
 using SemWeb;
 using Mono.Unix;
 
-namespace FSpot.Iptc {
+namespace Beagle.Util.Iptc {
 	public enum Format
 	{
 		Unknown,
@@ -278,7 +308,7 @@ namespace FSpot.Iptc {
 			RecordNumber = rec [1];
 			DataSetNumber = rec [2];
 
-			ulong length = FSpot.BitConverter.ToUInt16 (rec, 3, false);			
+			ulong length = BitConverter.ToUInt16 (rec, 3, false);			
 
 			if ((length & (LengthMask)) > 0) {
 				// Note: if the high bit of the length is set the record is more than 32k long
@@ -290,7 +320,7 @@ namespace FSpot.Iptc {
 
 				byte [] ldata = new byte [8];
 				stream.Read (ldata, 8 - lsize, lsize);
-				length = FSpot.BitConverter.ToUInt64 (ldata, 0, false);
+				length = BitConverter.ToUInt64 (ldata, 0, false);
 			}
 
 			// FIXME if the length is greater than 32768 we re
@@ -320,12 +350,12 @@ namespace FSpot.Iptc {
 			stream.WriteByte (RecordNumber);
 			stream.WriteByte (DataSetNumber);
 			if (Data.Length < LengthMask) {
-				byte [] len = FSpot.BitConverter.GetBytes ((ushort)Data.Length, false);
+				byte [] len = BitConverter.GetBytes ((ushort)Data.Length, false);
 				stream.Write (len, 0, len.Length);
 			} else {
-				byte [] len =  FSpot.BitConverter.GetBytes ((ushort)LengthMask & 8, false);
+				byte [] len =  BitConverter.GetBytes ((ushort)LengthMask & 8, false);
 				stream.Write (len, 0, len.Length);
-				len = FSpot.BitConverter.GetBytes ((ulong) Data.Length, false);
+				len = BitConverter.GetBytes ((ulong) Data.Length, false);
 				stream.Write (len, 0, len.Length);
 			}
 			stream.Write (Data, 0, Data.Length);
@@ -411,8 +441,8 @@ namespace FSpot.Iptc {
 					//System.Console.WriteLine (e.ToString ());
 				}
 				//DataSetInfo info = DataSetInfo.FindInfo (data.ID);
-				//System.Console.WriteLine ("{0}:{1} - {2} {3}", data.RecordNumber, data.DataSetNumber, 
-				//			  data.ID.ToString (), info.Description);
+				System.Console.WriteLine ("{0}:{1} - {2} {3}", data.RecordNumber, data.DataSetNumber, 
+							  data.ID.ToString (), "hoo");
 				sets.Add (data);
 			}
 		}
--- /usr/share/devel/f-spot-0.3.0/src/JpegHeader.cs	2006-11-28 16:41:37.000000000 -0500
+++ JpegHeader.cs	2006-12-22 14:57:30.340000000 -0500
@@ -1,4 +1,7 @@
 /*
+ * Authors:
+ *     Larry Ewing <lewing@novell.com>
+ *
  * Copyright (c) 2006 Novell Inc. 
  *
  * This program is free software; you can redistribute it and/or
@@ -20,13 +23,8 @@
 using System;
 using System.IO;
 using System.Collections;
-using FSpot.Xmp;
-using FSpot;
-
-#if ENABLE_NUNIT
-using NUnit.Framework;
-#endif
 
+namespace Beagle.Util {
 public class JpegHeader : SemWeb.StatementSource {
 	public enum JpegMarker {
 		Tem = 0x01,
@@ -214,7 +212,7 @@ public class JpegHeader : SemWeb.Stateme
 				return new Marker (id, null);
 			default:
 				Read (stream, raw, 0, 2);
-				length = FSpot.BitConverter.ToUInt16 (raw, 0, false);
+				length = BitConverter.ToUInt16 (raw, 0, false);
 				
 				byte [] data = new byte [length - 2];
 				Read (stream, data, 0, data.Length);
@@ -240,7 +238,7 @@ public class JpegHeader : SemWeb.Stateme
 				stream.WriteByte ((byte)this.Type);
 				ushort length = (ushort)(this.Data.Length + 2);
 				
-				byte [] len = FSpot.BitConverter.GetBytes (length, false);
+				byte [] len = BitConverter.GetBytes (length, false);
 				stream.Write (len, 0, len.Length);
 
 				stream.Write (this.Data, 0, this.Data.Length);
@@ -250,6 +248,7 @@ public class JpegHeader : SemWeb.Stateme
 	}
 
 	public static Signature JfifSignature = new Signature (JpegMarker.App0, "JFIF\0");
+	public static Signature ComSignature = new Signature (JpegMarker.Com, "COM\0");
 	public static Signature JfxxSignature = new Signature (JpegMarker.App0, "JFXX\0");
 	public static Signature XmpSignature = new Signature (JpegMarker.App1, "http://ns.adobe.com/xap/1.0/\0");
 	public static Signature ExifSignature = new Signature (JpegMarker.App1, "Exif\0\0");
@@ -291,6 +290,8 @@ public class JpegHeader : SemWeb.Stateme
 		return FindMarker (new Signature (id, name));
 	}
 
+//FIXME: Do we need CMS profile ?
+#if FALSE
 	public Cms.Profile GetProfile ()
 	{
 		Marker m = FindMarker (IccProfileSignature);
@@ -302,14 +303,15 @@ public class JpegHeader : SemWeb.Stateme
 			System.Console.WriteLine (e);
 		}
 		
-		FSpot.Tiff.Header exif = GetExifHeader ();
+		Tiff.Header exif = GetExifHeader ();
 		if (exif != null)
 			return exif.Directory.GetProfile ();
 		
 		return null;
 	}
-	
-	public FSpot.Tiff.Header GetExifHeader ()
+#endif
+
+	public Tiff.Header GetExifHeader ()
 	{
 		string name = ExifSignature.Name;
 		Marker marker = FindMarker (ExifSignature);
@@ -318,12 +320,26 @@ public class JpegHeader : SemWeb.Stateme
 			return null;
 		
 		using (System.IO.Stream exifstream = new System.IO.MemoryStream (marker.Data, name.Length, marker.Data.Length - name.Length, false)) {
-			FSpot.Tiff.Header exif = new FSpot.Tiff.Header (exifstream);
+			Tiff.Header exif = new Tiff.Header (exifstream);
 			return exif;
 		}
 	}
 
-	public XmpFile GetXmp ()
+	public string GetJFIFComment ()
+	{
+		string name = ComSignature.Name;
+		Marker marker = FindMarker (ComSignature);
+
+		if (marker == null)
+			return null;
+
+		if (marker.Data != null && marker.Data.Length != 0)
+			return System.Text.Encoding.Default.GetString (marker.Data, 0, marker.Data.Length);
+
+		return null;
+	}
+
+	public Xmp.XmpFile GetXmp ()
 	{
 		string name = XmpSignature.Name;
 		Marker marker = FindMarker (XmpSignature);
@@ -334,7 +350,7 @@ public class JpegHeader : SemWeb.Stateme
 			using (System.IO.Stream xmpstream = new System.IO.MemoryStream (marker.Data, len, 
 											marker.Data.Length - len, false)) {
 			
-				XmpFile xmp = new XmpFile (xmpstream);					
+				Xmp.XmpFile xmp = new Xmp.XmpFile (xmpstream);					
 				return xmp;
 			}
 		}
@@ -343,11 +359,11 @@ public class JpegHeader : SemWeb.Stateme
 
 	public void Select (SemWeb.StatementSink sink)
 	{
-		FSpot.Tiff.Header exif = GetExifHeader ();
+		Tiff.Header exif = GetExifHeader ();
 		if (exif != null)
 			exif.Select (sink);
 		
-		XmpFile xmp = GetXmp ();
+		Xmp.XmpFile xmp = GetXmp ();
 		if (xmp != null)
 			xmp.Select (sink);
 		
@@ -356,7 +372,7 @@ public class JpegHeader : SemWeb.Stateme
 		if (marker != null) {
 			int len = name.Length;
 			using (System.IO.Stream bimstream = new System.IO.MemoryStream (marker.Data, len, marker.Data.Length - len, false)) {
-				FSpot.Bim.BimFile bim = new FSpot.Bim.BimFile (bimstream);
+				Bim.BimFile bim = new Bim.BimFile (bimstream);
 				bim.Select (sink);
 			}
 		}
@@ -410,7 +426,7 @@ public class JpegHeader : SemWeb.Stateme
 		// Console.WriteLine ("replaced");
 	}	
 	
-	public void SetXmp (XmpFile xmp)
+	public void SetXmp (Xmp.XmpFile xmp)
 	{
 		using (MemoryStream stream = new MemoryStream ()) {
 			
@@ -441,7 +457,7 @@ public class JpegHeader : SemWeb.Stateme
 
 	public JpegHeader (System.IO.Stream stream)
 	{
-		Load (stream, false);
+		Load (stream, true);
 	}
 
 	public JpegHeader (System.IO.Stream stream, bool metadata_only)
@@ -548,7 +564,7 @@ public class JpegHeader : SemWeb.Stateme
 					uint val;
 					
 					if ((tableindex >> 4) > 0) {
-					        val = FSpot.BitConverter.ToUInt16 (dqt.Data, position, false);
+					        val = BitConverter.ToUInt16 (dqt.Data, position, false);
 						position += 2;
 					} else
 						val = (uint) dqt.Data [position ++];
@@ -604,12 +620,12 @@ public class JpegHeader : SemWeb.Stateme
 		public string CreateFile ()
 		{
 			Gdk.Pixbuf test = new Gdk.Pixbuf (null, "f-spot-32.png");
-			string path = FSpot.ImageFile.TempPath ("joe.jpg");
+			string path = ImageFile.TempPath ("joe.jpg");
 			string desc = "\x00a9 Novell Inc.";
 			PixbufOrientation orient = PixbufOrientation.TopRight;
 
 			PixbufUtils.SaveJpeg (test, path, quality, new Exif.ExifData ());
-			FSpot.JpegFile jimg = new FSpot.JpegFile (path);
+			JpegFile jimg = new JpegFile (path);
 			jimg.SetDescription (desc);
 			jimg.SetOrientation (orient);
 			jimg.SaveMetaData (path);
@@ -720,3 +736,4 @@ public class JpegHeader : SemWeb.Stateme
 	}
 #endif
 }
+}
--- /usr/share/devel/f-spot-0.3.0/src/MetadataStore.cs	2006-11-16 18:20:14.000000000 -0500
+++ MetadataStore.cs	2006-12-22 14:54:36.400000000 -0500
@@ -1,9 +1,37 @@
+//
+// MetadataStore.cs
+//
+// Authors:
+//     Larry Ewing <lewing@novell.com>
+//
+//
+// Copyright (C) 2004 - 2006 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
 using SemWeb;
 using SemWeb.Util;
 using Mono.Unix;
-using FSpot.Xmp;
 
-namespace FSpot {
+namespace Beagle.Util {
         internal class Description {
 		string predicate;
 		string description;
@@ -20,49 +48,49 @@ namespace FSpot {
 				new Description ("dc:rights", Catalog.GetString ("Copyright")),
 				new Description ("dc:subject", Catalog.GetString ("Subject and Keywords")),
 				new Description ("tiff:Compression", Catalog.GetString ("Compression"), 
-						 typeof (FSpot.Tiff.Compression)),
+						 typeof (Tiff.Compression)),
 				new Description ("tiff:PlanarConfiguration", Catalog.GetString ("Planar Configuration"), 
-						 typeof (FSpot.Tiff.PlanarConfiguration)),
+						 typeof (Tiff.PlanarConfiguration)),
 				new Description ("tiff:Orientation", Catalog.GetString ("Orientation"), 
 						 typeof (PixbufOrientation)),
 				new Description ("tiff:PhotometricInterpretation", Catalog.GetString ("Photometric Interpretation"), 
-						 typeof (FSpot.Tiff.PhotometricInterpretation)),
+						 typeof (Tiff.PhotometricInterpretation)),
 				new Description ("tiff:ResolutionUnit", Catalog.GetString ("Resolution Unit"),
-						 typeof (FSpot.Tiff.ResolutionUnit)),
+						 typeof (Tiff.ResolutionUnit)),
 				new Description ("exif:ExposureProgram", Catalog.GetString ("Exposure Program"), 
-						 typeof (FSpot.Tiff.ExposureProgram)),
+						 typeof (Tiff.ExposureProgram)),
 				new Description ("exif:MeteringMode", Catalog.GetString ("Metering Mode"), 
-						 typeof (FSpot.Tiff.MeteringMode)),
+						 typeof (Tiff.MeteringMode)),
 				new Description ("exif:ExposureMode", Catalog.GetString ("Exposure Mode"), 
-						 typeof (FSpot.Tiff.ExposureMode)),
+						 typeof (Tiff.ExposureMode)),
 				new Description ("exif:CustomRendered", Catalog.GetString ("Custom Rendered"), 
-						 typeof (FSpot.Tiff.CustomRendered)),
+						 typeof (Tiff.CustomRendered)),
 				new Description ("exif:ComponentsConfiguration", Catalog.GetString ("Components Configuration"),
-						 typeof (FSpot.Tiff.ComponentsConfiguration)),
+						 typeof (Tiff.ComponentsConfiguration)),
 				new Description ("exif:LightSource", Catalog.GetString ("Light Source"),
-						 typeof (FSpot.Tiff.LightSource)),
+						 typeof (Tiff.LightSource)),
 				new Description ("exif:SensingMethod", Catalog.GetString ("Sensing Method"),
-						 typeof (FSpot.Tiff.SensingMethod)),
+						 typeof (Tiff.SensingMethod)),
 				new Description ("exif:ColorSpace", Catalog.GetString ("Color Space"),
-						 typeof (FSpot.Tiff.ColorSpace)),
+						 typeof (Tiff.ColorSpace)),
 				new Description ("exif:WhiteBalance", Catalog.GetString ("White Balance"),
-						 typeof (FSpot.Tiff.WhiteBalance)),
+						 typeof (Tiff.WhiteBalance)),
 				new Description ("exif:FocalPlaneResolutionUnit", Catalog.GetString ("Focal Plane Resolution Unit"),
-						 typeof (FSpot.Tiff.ResolutionUnit)),
+						 typeof (Tiff.ResolutionUnit)),
 				new Description ("exif:FileSource", Catalog.GetString ("File Source Type"),
-						 typeof (FSpot.Tiff.FileSource)),
+						 typeof (Tiff.FileSource)),
 				new Description ("exif:SceneCaptureType", Catalog.GetString ("Scene Capture Type"),
-						 typeof (FSpot.Tiff.SceneCaptureType)),
+						 typeof (Tiff.SceneCaptureType)),
 				new Description ("exif:GainControl", Catalog.GetString ("Gain Control"),
-						 typeof (FSpot.Tiff.GainControl)),
+						 typeof (Tiff.GainControl)),
 				new Description ("exif:Contrast", Catalog.GetString ("Contrast"),
-						 typeof (FSpot.Tiff.Contrast)),
+						 typeof (Tiff.Contrast)),
 				new Description ("exif:Saturation", Catalog.GetString ("Saturation"),
-						 typeof (FSpot.Tiff.Saturation)),
+						 typeof (Tiff.Saturation)),
 				new Description ("exif:Sharpness", Catalog.GetString ("Sharpness"),
-						 typeof (FSpot.Tiff.Sharpness)),
+						 typeof (Tiff.Sharpness)),
 				new Description ("exif:SceneType", Catalog.GetString ("Scene Type"),
-						 typeof (FSpot.Tiff.SceneType))
+						 typeof (Tiff.SceneType))
 
 
 
@@ -144,7 +172,7 @@ namespace FSpot {
 			}
 			/*
 			else if (type == typeof (Rational)) {
-				object o = FSpot.Tiff.Rational.Parse (obj.Value);
+				object o = Tiff.Rational.Parse (obj.Value);
 			} 
 			*/
 			return result;
--- /usr/share/devel/f-spot-0.3.0/src/PixbufUtils.cs	2006-11-16 17:16:49.000000000 -0500
+++ PixbufUtils.cs	2006-12-22 14:57:53.580000000 -0500
@@ -1,9 +1,36 @@
-using Gdk;
+//
+// PixbufUtils.cs
+//
+// Authors:
+//     Larry Ewing <lewing@novell.com>
+//
+//
+// Copyright (C) 2004 - 2006 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
 using System.Collections;
 using System.Runtime.InteropServices;
 using System;
 using System.IO;
-using FSpot;
 
 /**
   1        2       3      4         5            6           7          8
@@ -18,6 +45,7 @@ t-l     t-r     b-r     b-l     l-t     
 
 **/
 
+namespace Beagle.Util {
 public enum PixbufOrientation {
 	TopLeft = 1,
 	TopRight = 2,
@@ -55,806 +83,5 @@ class PixbufUtils {
 		orientation = Rotate270 (orientation);
 		return orientation;
 	}
-
-	public static Pixbuf ErrorPixbuf = PixbufUtils.LoadFromAssembly ("f-spot-question-mark.png");
-	public static Pixbuf LoadingPixbuf = PixbufUtils.LoadFromAssembly ("f-spot-loading.png");
-
-	public static int GetSize (Pixbuf pixbuf)
-	{
-		return Math.Max (pixbuf.Width, pixbuf.Height);
-	}
-
-	public static double Fit (Pixbuf pixbuf,
-				  int dest_width, int dest_height,
-				  bool upscale_smaller,
-				  out int fit_width, out int fit_height)
-	{
-		return Fit (pixbuf.Width, pixbuf.Height, 
-			    dest_width, dest_height, 
-			    upscale_smaller, 
-			    out fit_width, out fit_height);
-	}
-
-	public static double Fit (int orig_width, int orig_height,
-				  int dest_width, int dest_height,
-				  bool upscale_smaller,
-				  out int fit_width, out int fit_height)
-	{
-		if (orig_width == 0 || orig_height == 0) {
-			fit_width = 0;
-			fit_height = 0;
-			return 0.0;
-		}
-
-		double scale = Math.Min (dest_width / (double)orig_width,
-					 dest_height / (double)orig_height);
-		
-		if (scale > 1.0 && !upscale_smaller)
-			scale = 1.0;
-
-		fit_width = (int)(scale * orig_width);
-		fit_height = (int)(scale * orig_height);
-		
-		return scale;
-	}
-
-
-	// FIXME: These should be in GTK#.  When my patch is committed, these LoadFrom* methods will
-	// go away.
-
-	public class AspectLoader {
-		Gdk.PixbufLoader loader = new Gdk.PixbufLoader ();
-		int max_width;
-		int max_height;
-		PixbufOrientation orientation;
-		int orig_width;
-
-		public AspectLoader (int max_width, int max_height) 
-		{
-			this.max_height = max_height;
-			this.max_width = max_width;
-			loader.SizePrepared += HandleSizePrepared;
-		}
-
-		private void HandleSizePrepared (object obj, SizePreparedArgs args)
-		{
-			switch (orientation) {
-			case PixbufOrientation.LeftTop:
-			case PixbufOrientation.LeftBottom:
-			case PixbufOrientation.RightTop:
-			case PixbufOrientation.RightBottom:	
-				int tmp = max_width;
-				max_width = max_height;
-				max_height = tmp;
-				break;
-			default:
-				break;
-			}
-
-			double scale = Math.Min (max_width / (double)args.Width,
-						 max_height / (double)args.Height);
-
-			
-			int scale_width = (int)(scale * args.Width);
-			int scale_height = (int)(scale * args.Height);
-
-			if (scale < 1.0)
-				loader.SetSize (scale_width, scale_height);
-		}
-
-		public Pixbuf Load (System.IO.Stream stream, PixbufOrientation orientation)
-		{
-			int count;
-			byte [] data = new byte [8192];
-			while (((count = stream.Read (data, 0, data.Length)) > 0) && loader.Write (data, (ulong)count))
-				;
-			
-			loader.Close ();
-			Pixbuf orig = loader.Pixbuf;
-			Gdk.Pixbuf rotated = TransformOrientation (orig, orientation, true);
-			
-			if (orig != rotated) {
-				CopyThumbnailOptions (orig, rotated);
-				orig.Dispose ();
-			}
-			loader.Dispose ();
-			return rotated;
-		}
-		
-		public Pixbuf LoadFromFile (string path)
-		{
-			FileStream fs = null;
-			
-			try {
-				orientation = GetOrientation (path);
-				using (fs = File.OpenRead (path)) {
-					return Load (fs, orientation);
-				}
-			} catch (Exception) {
-				System.Console.WriteLine ("Error loading photo {0}", path);
-				return null;
-			} 
-		}
-	}
-
-	public static Pixbuf ShallowCopy (Pixbuf pixbuf)
-	{
-		Pixbuf result = new Pixbuf (pixbuf, 0, 0, pixbuf.Width, pixbuf.Height);
-		CopyThumbnailOptions (pixbuf, result);
-		return result;
-	}
-
-	public static Pixbuf ScaleToMaxSize (Pixbuf pixbuf, int width, int height)
-	{
-		return ScaleToMaxSize (pixbuf, width, height, true);
-	}	
-
-	public static Pixbuf ScaleToMaxSize (Pixbuf pixbuf, int width, int height, bool upscale)
-	{
-		double scale = Math.Min  (width / (double)pixbuf.Width, height / (double)pixbuf.Height);
-		int scale_width = (int)(scale * pixbuf.Width);
-		int scale_height = (int)(scale * pixbuf.Height);
-
-		Gdk.Pixbuf result;
-		if (upscale || (scale < 1.0))
-			result = pixbuf.ScaleSimple (scale_width, scale_height, (scale_width > 20) ? Gdk.InterpType.Bilinear : Gdk.InterpType.Nearest);
-		else
-			result = pixbuf.Copy ();
-
-		CopyThumbnailOptions (pixbuf, result);
-
-		return result;
-	}
-		
-	static public void GetSize (string path, out int width, out int height)
-	{
-		Gdk.PixbufLoader loader = new Gdk.PixbufLoader ();
-		int orig_width = 0;
-		int orig_height = 0;
-		bool done = false;
-
-		loader.SizePrepared += delegate (object obj, SizePreparedArgs args) {
-			orig_width = args.Width;
-			orig_height = args.Height;
-			done = true;
-		};
-		
-		using (Stream stream = File.OpenRead (path)) {
-			byte [] data = new byte [4096];
-			int count;
-
-			while (((count = stream.Read (data, 0, data.Length)) > 0) && loader.Write (data, (ulong)count)) {
-				if (done)
-					break;
-			}
-		}
-		
-		width = orig_width;
-		height = orig_height;
-	}
-
-	static public Pixbuf LoadAtMaxSize (string path, int max_width, int max_height)
-	{
-#if true
-		PixbufUtils.AspectLoader loader = new AspectLoader (max_width, max_height);
-		return loader.LoadFromFile (path);
-#else
-		int width, height;
-		JpegUtils.GetSize (path, out width, out height);
-		PixbufUtils.Fit (width, height, max_width, max_height, false, out width, out height);
-		Gdk.Pixbuf image = JpegUtils.LoadScaled (path, width, height);
-		
-		return image;
-#endif
-	}
-
-	static public Pixbuf LoadFromStream (System.IO.Stream input)
-	{
-		Gdk.PixbufLoader loader = new Gdk.PixbufLoader ();
-		byte [] buffer = new byte [8192];
-		int n;
-
-		while ((n = input.Read (buffer, 0, 8192)) != 0)
-			loader.Write (buffer, (ulong) n);
-		
-		loader.Close ();
-		
-		return loader.Pixbuf;
-		
-	}
-	
-
-	// 
-	// FIXME this is actually not public api and we should do a verison check,
-	// but frankly I'm irritated that it isn't public so I don't much care.
-	//
-	[DllImport("libgdk_pixbuf-2.0-0.dll")]
-	static extern bool gdk_pixbuf_set_option(IntPtr raw, string key, string value);
-	
-	public static bool SetOption(Gdk.Pixbuf pixbuf, string key, string value)
-	{
-		
-		if (value != null)
-			return gdk_pixbuf_set_option(pixbuf.Handle, key, value);
-		else
-			return false;
-	}
-	
-	public static void CopyThumbnailOptions (Gdk.Pixbuf src, Gdk.Pixbuf dest)
-	{
-		if (src != null && dest != null) {
-			PixbufUtils.SetOption (dest, "tEXt::Thumb::URI", src.GetOption ("tEXt::Thumb::URI"));
-			PixbufUtils.SetOption (dest, "tEXt::Thumb::MTime", src.GetOption ("tEXt::Thumb::MTime"));
-		}
-	}
-
-	public static void Save (Gdk.Pixbuf pixbuf, System.IO.Stream stream, string type, string [] options, string [] values)
-	{
-		byte [] data;
-
-		data = PixbufUtils.Save (pixbuf, type, options, values);
-		stream.Write (data, 0, data.Length);
-	}
-
-	[DllImport("libgdk_pixbuf-2.0-0.dll")]
-	static extern bool gdk_pixbuf_save_to_bufferv (IntPtr raw, out IntPtr data, out IntPtr length, 
-						       string type, 
-						       string [] keys, string [] values, out IntPtr error);
-
-					
-	public static byte [] Save (Gdk.Pixbuf pixbuf, string type, string [] options, string [] values)
-	{
-		IntPtr error = IntPtr.Zero;
-		IntPtr data;
-		IntPtr length;
-		string [] terminated_options = options;
-		string [] terminated_values = values;
-
-		if (options != null && options [ options.Length - 1 ] != null) {
-			terminated_options = new string [options.Length + 1];
-			Array.Copy (options, terminated_options, options.Length);
-		}
-
-		if (values != null && values [ values.Length - 1] != null) {
-			terminated_values = new string [values.Length + 1];
-			Array.Copy (values, terminated_values, values.Length);
-		}
-		
-		if (terminated_options != null)
-			System.Console.WriteLine ("options = {0}, values = {1}", terminated_options [0], terminated_values [0]);
-		else
-			Console.WriteLine ("no options");
-
-		bool success = gdk_pixbuf_save_to_bufferv (pixbuf.Handle, 
-							     out data, 
-							     out length, 
-							     type,
-							     terminated_options,
-							     terminated_values,
-							     out error);
-		
-		if (error != IntPtr.Zero) 
-			throw new GLib.GException (error);
-
-		if (!success)
-			throw new ApplicationException ("Unknown error while saving file");
-
-		byte [] content = new byte [(int)length];
-		Marshal.Copy (data, content, 0, (int)length);
-
-		return content;
-	}
-	
-	public static Pixbuf TagIconFromPixbuf (Pixbuf source)
-	{
-		// FIXME 50x50 crashes Pixdata.Serialize... what a mess.
-		int size = 52;
-		Pixbuf tmp = null;
-		Pixbuf icon = null;
-
-		if (source.Width > source.Height)
-			source = tmp = new Pixbuf (source, (source.Width - source.Height) /2, 0, source.Height, source.Height);
-		else if (source.Width < source.Height) 
-			source = tmp = new Pixbuf (source, 0, (source.Height - source.Width) /2, source.Width, source.Width);
-
-		if (source.Width == source.Height)
-			icon = source.ScaleSimple (size, size, InterpType.Bilinear);
-		else
-			throw new Exception ("Bad logic leads to bad accidents");
-
-		if (tmp != null)
-			tmp.Dispose ();
-		
-		return icon;
-	}
-		
-	static public Pixbuf LoadFromScreen (Gdk.Window win) {
-		Gdk.Screen screen = win.Screen;
-		Drawable d = screen.RootWindow;
-		int monitor = screen.GetMonitorAtWindow (win);
-		Gdk.Rectangle geom = screen.GetMonitorGeometry (monitor);
-		
-		//
-		// We use the screen width and height because that reflects
-		// the current resolution, the RootWindow can actually be different.
-		//
-
-		Pixbuf buf = new Pixbuf (Colorspace.Rgb, false, 8, geom.Width, geom.Height);
-		
-		return buf.GetFromDrawable (d,
-					    d.Colormap, geom.X, geom.Y, 0, 0, 
-					    geom.Width, geom.Height);
-	}
-
-	static public Pixbuf LoadFromScreen () {
-		Screen screen = Display.Default.GetScreen (0);
-		Drawable d = screen.RootWindow;
-		int width = screen.Width;
-		int height = screen.Height;
-		
-		//
-		// We use the screen width and height because that reflects
-		// the current resolution, the RootWindow can actually be different.
-		//
-
-		Pixbuf buf = new Pixbuf (Colorspace.Rgb, false, 8, width, height);
-		
-		return buf.GetFromDrawable (d,
-					    d.Colormap, 0, 0, 0, 0, 
-					    width, height);
-	}
-
-	static public Pixbuf LoadFromAssembly (string resource)
-	{
-		try {
-			return new Pixbuf (System.Reflection.Assembly.GetEntryAssembly (), resource);
-		} catch {
-			return null;
-		}
-	}
-
-	[DllImport ("libc")]
-	static extern int rename (string oldpath, string newpath);
-
-	public static void SaveAtomic (Gdk.Pixbuf src, string filename, string type, string [] keys, string [] values)
-	{
-			string tmpname = filename + ".tmp";
-			src.Savev (tmpname, type, keys, values);
-			if (rename (tmpname, filename) < 0)
-				throw new Exception ("Error renaming file");
-	}
-
-	public static Gdk.Pixbuf ScaleToAspect (Gdk.Pixbuf orig, int width, int height)
-	{
-		Gdk.Rectangle pos;
-		double scale = Fit (orig, width, height, false, out pos.Width, out pos.Height);
-		pos.X = (width - pos.Width) / 2;
-		pos.Y = (height - pos.Height) / 2;
-
-		Pixbuf scaled = new Pixbuf (Colorspace.Rgb, false, 8, width, height);
-		scaled.Fill (0x000000); 
-
-		orig.Composite (scaled, pos.X, pos.Y, 
-				pos.Width, pos.Height,
-				pos.X, pos.Y, scale, scale,
-				Gdk.InterpType.Bilinear,
-				255);
-
-		return scaled;
-	}
-
-	public static string Resize (string orig_path, int size, bool copy_meta)
-	{
-		string version_path = System.IO.Path.GetTempFileName ();
-		Resize (orig_path, version_path, size, copy_meta);
-		return version_path;
-	}
-
-	public static void Resize (string orig_path, string dest_path, int size, bool copy_meta)
-	{
-		Exif.ExifData exif_data;
-		if (copy_meta)
-			exif_data = new Exif.ExifData (orig_path);
-		else 
-			exif_data = new Exif.ExifData ();
-
-		Gdk.Pixbuf image = PixbufUtils.LoadAtMaxSize (orig_path, size, size);
-
-		PixbufUtils.SaveJpeg (image, dest_path, 95, exif_data);
-		image.Dispose ();
-	}
-	
-
-	public static Pixbuf Flatten (Pixbuf pixbuf)
-	{
-		if (!pixbuf.HasAlpha)
-			return null;
-
-		Pixbuf flattened = new Pixbuf (Colorspace.Rgb, false, 8, pixbuf.Width, pixbuf.Height);
-		pixbuf.CompositeColor (flattened, 0, 0, 
-				       pixbuf.Width, pixbuf.Height, 
-				       0, 0, 1, 1, 
-				       InterpType.Bilinear,
-				       255, 0, 0, 2000, 0xffffff, 0xffffff);
-
-		return flattened;
-	}
-
-	[StructLayout(LayoutKind.Sequential)]
-	public unsafe struct FPixbufJpegMarker {
-		public int type;
-		public byte *data;
-		public int length;
-	}
-
-	[DllImport ("libfspot")]
-	static extern bool f_pixbuf_save_jpeg (IntPtr src, string path, int quality, FPixbufJpegMarker [] markers, int num_markers);
-
-	public static void SaveJpeg (Pixbuf pixbuf, string path, int quality, Exif.ExifData exif_data)
-	{
-		Pixbuf temp = null;
-		if (pixbuf.HasAlpha) {
-			temp = Flatten (pixbuf);
-			pixbuf = temp;
-		}
-
-		// The DCF spec says thumbnails should be 160x120 always
-		Pixbuf thumbnail = ScaleToAspect (pixbuf, 160, 120);
-		byte [] thumb_data = Save (thumbnail, "jpeg", null, null);
-		exif_data.Data = thumb_data;
-		thumbnail.Dispose ();
-
-		// Most of the things we will set will be in the 0th ifd
-		Exif.ExifContent content = exif_data.GetContents (Exif.Ifd.Zero);
-
-		// reset the orientation tag the default is top/left
-		content.GetEntry (Exif.Tag.Orientation).Reset ();
-
-		// set the write time in the datetime tag
-		content.GetEntry (Exif.Tag.DateTime).Reset ();
-
-		// set the software tag
-		content.GetEntry (Exif.Tag.Software).SetData (FSpot.Defines.PACKAGE + " version " + FSpot.Defines.VERSION);
-
-		byte [] data = exif_data.Save ();
-		FPixbufJpegMarker [] marker = new FPixbufJpegMarker [0];
-		bool result = false;
-
-		unsafe {
-			if (data.Length > 0) {
-				
-				fixed (byte *p = data) {
-					marker = new FPixbufJpegMarker [1];
-					marker [0].type = 0xe1; // APP1 marker
-					marker [0].data = p;
-					marker [0].length = data.Length;
-					
-					result = f_pixbuf_save_jpeg (pixbuf.Handle, path, quality, marker, marker.Length);
-				}					
-			} else
-				result = f_pixbuf_save_jpeg (pixbuf.Handle, path, quality, marker, marker.Length);
-			
-		}
-
-		if (temp != null)
-			temp.Dispose ();
-		
-		if (result == false)
-			throw new System.Exception ("Error Saving File");
-	}
-
-	[DllImport ("libgtk-win32-2.0-0.dll")]
-	extern static IntPtr gtk_icon_theme_get_default ();
-
-	[DllImport ("libgtk-win32-2.0-0.dll")]
-	extern static IntPtr gtk_icon_theme_load_icon (IntPtr theme, string name, int size, int flags, IntPtr error);
-	
-	public static Gdk.Pixbuf LoadThemeIcon (string name, int size)
-	{
-		try {
-			IntPtr native = gtk_icon_theme_load_icon (gtk_icon_theme_get_default (), name, size, 0, IntPtr.Zero);
-			if (native != IntPtr.Zero) {
-				Gdk.Pixbuf ret = (Gdk.Pixbuf) GLib.Object.GetObject(native, true);
-				return ret;
-			}
-		} catch (System.Exception e) {
-			System.Console.Write (e.ToString ());
-		}
-		return null;
-	}
-
-
-	[DllImport ("libfspot")]
-	static extern IntPtr f_pixbuf_unsharp_mask (IntPtr src, double radius, double amount, double threshold);
-
-	public static Pixbuf UnsharpMask (Pixbuf src, double radius, double amount, double threshold)
-	{
-		IntPtr raw_ret = f_pixbuf_unsharp_mask (src.Handle, radius, amount, threshold);
- 		Gdk.Pixbuf ret = (Gdk.Pixbuf) GLib.Object.GetObject(raw_ret, true);
-		return ret;
-	}	
-	
-	[DllImport ("libfspot")]
-	static extern void f_pixbuf_remove_redeye (IntPtr src);
-	
-	public static Gdk.Pixbuf RemoveRedeye (Gdk.Pixbuf src, Gdk.Rectangle area)
-	{
-		Gdk.Pixbuf copy = src.Copy ();
-		Gdk.Pixbuf selection = new Gdk.Pixbuf (copy, area.X, area.Y, area.Width, area.Height);
-
-		f_pixbuf_remove_redeye (selection.Handle);
-		selection.Dispose ();
-
-		return copy;
-	}
-
-	public static unsafe Pixbuf ColorAdjust (Pixbuf src, double brightness, double contrast,
-					  double hue, double saturation, int src_color, int dest_color)
-	{
-		Pixbuf adjusted = new Pixbuf (Colorspace.Rgb, src.HasAlpha, 8, src.Width, src.Height);
-		PixbufUtils.ColorAdjust (src, adjusted, brightness, contrast, hue, saturation, src_color, dest_color);
-		return adjusted;
-	}
-
-	public static Cms.Format PixbufCmsFormat (Pixbuf buf)
-	{
-		return buf.HasAlpha ? Cms.Format.Rgba8Planar : Cms.Format.Rgb8;
-	}
-
-	public static unsafe void ColorAdjust (Pixbuf src, Pixbuf dest, 
-					       double brightness, double contrast,
-					       double hue, double saturation, 
-					       int src_color, int dest_color)
-	{
-		if (src.Width != dest.Width || src.Height != dest.Height)
-			throw new Exception ("Invalid Dimensions");
-
-		//Cms.Profile eos10d = new Cms.Profile ("/home/lewing/ICCProfiles/EOS-10D-True-Color-Non-Linear.icm");
-		Cms.Profile srgb = Cms.Profile.CreateStandardRgb ();
-
-		Cms.Profile bchsw = Cms.Profile.CreateAbstract (256, 
-								0.0, 
-								brightness, contrast,
-								hue, saturation, src_color, 
-								dest_color);
-
-		Cms.Profile [] list = new Cms.Profile [] { srgb, bchsw, srgb };
-		Cms.Transform trans = new Cms.Transform (list, 
-							 PixbufCmsFormat (src),
-							 PixbufCmsFormat (dest),
-							 Cms.Intent.Perceptual, 0x0100);
-
-		ColorAdjust (src, dest, trans);
-
-		trans.Dispose ();
-		srgb.Dispose ();
-		bchsw.Dispose ();
-	}
-
-
-	public static unsafe void ColorAdjust (Gdk.Pixbuf src, Gdk.Pixbuf dest, Cms.Transform trans)
-	{
-		int width = src.Width;
-		byte * srcpix  = (byte *) src.Pixels;
-		byte * destpix = (byte *) dest.Pixels;
-
-		for (int row = 0; row < src.Height; row++) {
-			trans.Apply ((IntPtr) (srcpix + row * src.Rowstride),
-				     (IntPtr) (destpix + row * dest.Rowstride), 
-				     (uint)width);
-		}
-		
-	}
-
-	public static Gdk.Pixbuf GetThumbnail (Exif.ExifData data)
-	{
-		byte [] thumb_data = data.Data;
-		if (thumb_data.Length > 0) {
-			PixbufOrientation orientation = GetOrientation (data);
-			MemoryStream mem = new MemoryStream (thumb_data);
-			Gdk.Pixbuf thumb = new Gdk.Pixbuf (mem);
-			Gdk.Pixbuf rotated = PixbufUtils.TransformOrientation (thumb, orientation);
-			
-			if (rotated != thumb)
-				thumb.Dispose ();
-			
-			return rotated;
-		}
-		return null;
-	}
-
-	public static PixbufOrientation GetOrientation (Exif.ExifData data)
-	{
-		PixbufOrientation orientation = PixbufOrientation.TopLeft;
-		
-		Exif.ExifEntry e = data.GetContents (Exif.Ifd.Zero).Lookup (Exif.Tag.Orientation);
-
-		if (e != null) {
-			ushort [] value = e.GetDataUShort ();
-			orientation = (PixbufOrientation) value [0];
-		}
-
-		return orientation;
-	}
-	
-	public static PixbufOrientation GetOrientation (string path)
-	{
-		FSpot.ImageFile img = FSpot.ImageFile.Create (path);
-		return img.Orientation;
-	}
-
-	[DllImport("libgnomeui-2-0.dll")]
-	static extern IntPtr gnome_thumbnail_scale_down_pixbuf(IntPtr pixbuf, int dest_width, int dest_height);
-
-	public static Gdk.Pixbuf ScaleDown (Gdk.Pixbuf src, int width, int height)
-	{
-		IntPtr raw_ret = gnome_thumbnail_scale_down_pixbuf(src.Handle, width, height);
-		Gdk.Pixbuf ret;
-		if (raw_ret == IntPtr.Zero)
-			ret = null;
-		else
-			ret = (Gdk.Pixbuf) GLib.Object.GetObject(raw_ret, true);
-		return ret;
-	}
-
-	public static Gdk.Pixbuf TransformOrientation (Gdk.Pixbuf src, PixbufOrientation orientation, bool copy_data)
-	{
-		Gdk.Pixbuf pixbuf;
-		if (src == null)
-			return null;
-		
-		switch (orientation) {
-		case PixbufOrientation.LeftTop:
-		case PixbufOrientation.LeftBottom:
-		case PixbufOrientation.RightTop:
-		case PixbufOrientation.RightBottom:	
-			pixbuf = new Gdk.Pixbuf (src.Colorspace, src.HasAlpha, 
-						 src.BitsPerSample,
-						 src.Height, src.Width);
-			break;
-		case PixbufOrientation.TopRight:
-		case PixbufOrientation.BottomRight:
-		case PixbufOrientation.BottomLeft:
-			pixbuf = new Gdk.Pixbuf (src.Colorspace, src.HasAlpha, 
-						 src.BitsPerSample,
-						 src.Width, src.Height);
-			break;
-		default:
-			pixbuf = src;
-			break;
-		}
-
-		if (copy_data && src != pixbuf) 
-			TransformAndCopy (src, pixbuf, orientation, new Gdk.Rectangle (0, 0, src.Width, src.Height));
-
-		return pixbuf;
-	}
-
-	public static Gdk.Pixbuf TransformOrientation (Gdk.Pixbuf src, PixbufOrientation orientation)
-	{
-		return TransformOrientation (src, orientation, true);
-	}
-
-	public static Gdk.Rectangle TransformOrientation (Gdk.Pixbuf src, Gdk.Rectangle args, PixbufOrientation orientation)
-	{
-		return TransformOrientation (src.Width, src.Height, args, orientation);
-	}
-	
-	public static Gdk.Rectangle TransformOrientation (int total_width, int total_height, Gdk.Rectangle args, PixbufOrientation orientation)
-	{
-		Gdk.Rectangle area = args;
-		
-		switch (orientation) {
-		case PixbufOrientation.BottomRight:
-			area.X = total_width - args.X - args.Width;
-			area.Y = total_height - args.Y - args.Height;
-			break;
-		case PixbufOrientation.TopRight:
-			area.X = total_width - args.X - args.Width;
-			break;
-		case PixbufOrientation.BottomLeft:
-			area.Y = total_height - args.Y - args.Height;
-			break;
-		case PixbufOrientation.LeftTop:
-			area.X = args.Y;
-			area.Y = args.X;
-			area.Width = args.Height;
-			area.Height = args.Width;
-			break;
-		case PixbufOrientation.RightBottom:
-			area.X = total_height - args.Y - args.Height;
-			area.Y = total_width - args.X - args.Width;
-			area.Width = args.Height;
-			area.Height = args.Width;
-			break;
-		case PixbufOrientation.RightTop:
-			area.X = total_height - args.Y - args.Height;
-			area.Y = args.X;
-			area.Width = args.Height;
-			area.Height = args.Width;
-			break;
-		case PixbufOrientation.LeftBottom:
-			area.X = args.Y;
-			area.Y = total_width - args.X - args.Width;
-			area.Width = args.Height;
-			area.Height = args.Width;
-			break;
-		default:
-			break;
-		}
-		
-		return area;
-	}
-	
-	public static Gdk.Rectangle TransformAndCopy (Gdk.Pixbuf src, Gdk.Pixbuf dest, PixbufOrientation orientation, Gdk.Rectangle args)
-	{
-		Gdk.Rectangle area = TransformOrientation (src, args, orientation);
-
-		int step = 256;
-
-		Gdk.Rectangle rect = new Gdk.Rectangle (args.X, args.Y, 
-							Math.Min (step, args.Width),
-							Math.Min (step, args.Height));
-
-		Gdk.Rectangle trect = TransformOrientation (src, rect, orientation);
-		Gdk.Pixbuf tmp = new Gdk.Pixbuf (src.Colorspace, src.HasAlpha, 
-						 src.BitsPerSample,
-						 trect.Width, trect.Height);
-
-		Gdk.Rectangle subarea;
-		BlockProcessor proc = new BlockProcessor (args, 256);
-		while (proc.Step (out subarea)) {
-			Gdk.Rectangle trans = TransformOrientation (src, subarea, orientation);
-			Gdk.Pixbuf ssub = new Gdk.Pixbuf (src, subarea.X, subarea.Y,
-							  subarea.Width, subarea.Height);
-
-			Gdk.Pixbuf tsub = new Gdk.Pixbuf (tmp, 0, 0, trans.Width, trans.Height);
-			CopyWithOrientation (ssub, tsub, orientation);
-
-			tsub.CopyArea (0, 0, trans.Width, trans.Height, dest, trans.X, trans.Y);
-			ssub.Dispose ();
-			tsub.Dispose ();
-		}
-
-		tmp.Dispose ();
-		return area;
-	}
-	// Bindings from libf.
-
-	[DllImport ("libfspot")]
-	static extern IntPtr f_pixbuf_copy_apply_brightness_and_contrast (IntPtr src, float brightness, float contrast);
-
-	public static Pixbuf ApplyBrightnessAndContrast (Pixbuf src, float brightness, float contrast)
-	{
-		return new Pixbuf (f_pixbuf_copy_apply_brightness_and_contrast (src.Handle, brightness, contrast));
-	}
-
-	[DllImport ("libfspot")]
-	static extern bool f_pixbuf_save_jpeg_atomic (IntPtr pixbuf, string filename, int quality, out IntPtr error);
-
-	public static void SaveAsJpegAtomically (Pixbuf pixbuf, string filename, int quality)
-	{
-		IntPtr error = IntPtr.Zero;
-
-		if (! f_pixbuf_save_jpeg_atomic (pixbuf.Handle, filename, quality, out error)) {
-			throw new GLib.GException (error);
-		}
-	}
-
-	[DllImport ("libfspot")]
-	static extern void f_pixbuf_copy_with_orientation (IntPtr src, IntPtr dest, int orientation);
-
-	public static void CopyWithOrientation (Gdk.Pixbuf src, Gdk.Pixbuf dest, PixbufOrientation orientation)
-	{
-		f_pixbuf_copy_with_orientation (src.Handle, dest.Handle, (int)orientation);
-	}
-
-#if false
-	[DllImport("glibsharpglue")]
-	static extern int gtksharp_object_get_ref_count (IntPtr obj);
-	
-	public static int RefCount (GLib.Object obj) {
-		return gtksharp_object_get_ref_count (obj.Handle);
-	}
-#endif
+}
 }
--- /usr/share/devel/f-spot-0.3.0/src/PngFile.cs	2006-11-28 11:58:13.000000000 -0500
+++ PngFile.cs	2006-12-16 01:50:24.296975000 -0500
@@ -1,8 +1,36 @@
+//
+// PngHeader.cs
+//
+// Authors:
+//     Larry Ewing <lewing@novell.com>
+//
+//
+// Copyright (C) 2004 - 2006 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
 using ICSharpCode.SharpZipLib.Zip.Compression;
 using SemWeb;
-using Cms;
+using System;
 using System.IO;
-using FSpot.Xmp;
 using System.Collections;
 using System.Reflection;
 
@@ -10,40 +38,15 @@ using System.Reflection;
 using NUnit.Framework;
 #endif
 
-namespace FSpot.Png {
-	public class PngFile : ImageFile, SemWeb.StatementSource {
-		PngHeader header;
-
-                // false seems a safe default
-                public bool Distinct {
-                        get { return false; }
-                }
-
-		private PngHeader Header {
-			get {
-				if (header == null) {
-					using (System.IO.Stream input = Open ()) {
-					        header = new PngHeader (input);
-					}
-				}
-				
-				return header;
-			}
-		}
-
-		public System.Collections.ArrayList Chunks {
-			get { return Header.Chunks; }
-		}
-
-		public PngFile (System.Uri uri) : base (uri)
-		{
-		}
-
-		public PngFile (string path) : base (path)
+namespace Beagle.Util {
+	public class PngHeader {
+		System.Collections.ArrayList chunk_list;
+		
+		public PngHeader (System.IO.Stream stream)
 		{
+			Load (stream);
 		}
 
-
 		/**
 		   Title 	Short (one line) title or caption for image 
 		   Author 	Name of image's creator
@@ -60,6 +63,7 @@ namespace FSpot.Png {
 
 		   Other keywords may be defined for other purposes. Keywords of general interest can be registered with th
 		*/
+		/*
 		public void Select (SemWeb.StatementSink sink)
 		{
 			foreach (Chunk c in Chunks) {
@@ -78,7 +82,7 @@ namespace FSpot.Png {
 					case "XMP":
 					case "XML:com.adobe.xmp":
 						System.IO.Stream xmpstream = new System.IO.MemoryStream (text.TextData);
-						FSpot.Xmp.XmpFile xmp = new FSpot.Xmp.XmpFile (xmpstream);
+						Xmp.XmpFile xmp = new Xmp.XmpFile (xmpstream);
 						xmp.Select (sink);
 						break;
 					case "Comment":
@@ -130,11 +134,16 @@ namespace FSpot.Png {
 					uint denominator = (uint) (phys.InMeters ? 100 : 1);
 					
 					MetadataStore.AddLiteral (sink, "tiff:ResolutionUnit", phys.InMeters ? "3" : "1");
-					MetadataStore.AddLiteral (sink, "tiff:XResolution", new FSpot.Tiff.Rational (phys.PixelsPerUnitX, denominator).ToString ());
-					MetadataStore.AddLiteral (sink, "tiff:YResolution", new FSpot.Tiff.Rational (phys.PixelsPerUnitY, denominator).ToString ());
+					MetadataStore.AddLiteral (sink, "tiff:XResolution", new Tiff.Rational (phys.PixelsPerUnitX, denominator).ToString ());
+					MetadataStore.AddLiteral (sink, "tiff:YResolution", new Tiff.Rational (phys.PixelsPerUnitY, denominator).ToString ());
 				}
 			}
 		}
+		*/
+
+		public System.Collections.ArrayList Chunks {
+			get { return chunk_list; }
+		}
 
 		public class ZtxtChunk : TextChunk {
 			//public static string Name = "zTXt";
@@ -402,7 +411,7 @@ namespace FSpot.Png {
 
 			public System.DateTime Time {
 				get {
-					return new System.DateTime (FSpot.BitConverter.ToUInt16 (data, 0, false),
+					return new System.DateTime (BitConverter.ToUInt16 (data, 0, false),
 								    data [2], data [3], data [4], data [5], data [6]);
 
 				}
@@ -430,11 +439,13 @@ namespace FSpot.Png {
 		public class StandardRgbChunk : Chunk {
 			public StandardRgbChunk (string name, byte [] data) : base (name, data) {}
 			
+#if false
 			public Cms.Intent RenderingIntent {
 				get {
 					return (Cms.Intent) data [0];
 				}
 			}
+#endif
 		}
 
 		public class GammaChunk : Chunk {
@@ -443,7 +454,7 @@ namespace FSpot.Png {
 
 			public double Gamma {
 				get {
-					return FSpot.BitConverter.ToUInt32 (data, 0, false) / (double) divisor;
+					return BitConverter.ToUInt32 (data, 0, false) / (double) divisor;
 				}
 			}
 		}
@@ -453,47 +464,48 @@ namespace FSpot.Png {
 			public const uint Denominator = 100000;
 
 			public ColorChunk (string name, byte [] data) : base (name, data) {}
-
-			public FSpot.Tiff.Rational WhiteX {
+/*
+			public Tiff.Rational WhiteX {
 				get {
-					return new FSpot.Tiff.Rational (FSpot.BitConverter.ToUInt32 (data, 0, false), Denominator);
+					return new Tiff.Rational (BitConverter.ToUInt32 (data, 0, false), Denominator);
 				}
 			}
-			public FSpot.Tiff.Rational WhiteY {
+			public Tiff.Rational WhiteY {
 				get { 
-					return new FSpot.Tiff.Rational (FSpot.BitConverter.ToUInt32 (data, 4, false), Denominator);
+					return new Tiff.Rational (BitConverter.ToUInt32 (data, 4, false), Denominator);
 				}
 			}
-			public FSpot.Tiff.Rational RedX {
+			public Tiff.Rational RedX {
 				get { 
-					return new FSpot.Tiff.Rational (FSpot.BitConverter.ToUInt32 (data, 8, false), Denominator);
+					return new Tiff.Rational (BitConverter.ToUInt32 (data, 8, false), Denominator);
 				}
 			}
-			public FSpot.Tiff.Rational RedY {
+			public Tiff.Rational RedY {
 				get { 
-					return new FSpot.Tiff.Rational (FSpot.BitConverter.ToUInt32 (data, 12, false), Denominator);
+					return new Tiff.Rational (BitConverter.ToUInt32 (data, 12, false), Denominator);
 				}
 			}
-			public FSpot.Tiff.Rational GreenX {
+			public Tiff.Rational GreenX {
 				get { 
-					return new FSpot.Tiff.Rational (FSpot.BitConverter.ToUInt32 (data, 16, false), Denominator);
+					return new Tiff.Rational (BitConverter.ToUInt32 (data, 16, false), Denominator);
 				}
 			}
-			public FSpot.Tiff.Rational GreenY {
+			public Tiff.Rational GreenY {
 				get { 
-					return new FSpot.Tiff.Rational (FSpot.BitConverter.ToUInt32 (data, 20, false), Denominator);
+					return new Tiff.Rational (BitConverter.ToUInt32 (data, 20, false), Denominator);
 				}
 			}
-			public FSpot.Tiff.Rational BlueX {
+			public Tiff.Rational BlueX {
 				get { 
-					return new FSpot.Tiff.Rational (FSpot.BitConverter.ToUInt32 (data, 24, false), Denominator);
+					return new Tiff.Rational (BitConverter.ToUInt32 (data, 24, false), Denominator);
 				}
 			}
-			public FSpot.Tiff.Rational BlueY {
+			public Tiff.Rational BlueY {
 				get { 
-					return new FSpot.Tiff.Rational (FSpot.BitConverter.ToUInt32 (data, 28, false), Denominator);
+					return new Tiff.Rational (BitConverter.ToUInt32 (data, 28, false), Denominator);
 				}
 			}
+			*/
 		}
 
 		public enum ColorType : byte {
@@ -531,7 +543,7 @@ namespace FSpot.Png {
 			public uint Height;
 			public byte Depth;
 			public ColorType Color;
-			public PngFile.CompressionMethod Compression;
+			public PngHeader.CompressionMethod Compression;
 			public FilterMethod Filter;
 			public InterlaceMethod Interlace;
 
@@ -848,569 +860,101 @@ namespace FSpot.Png {
 			}
 		}
 
-		public class ScanlineDecoder {
-			int width;
-			int height;
-			int row;
-			int col;
-			ChunkInflater inflater;
-			byte [] buffer;
-
-			public ScanlineDecoder (ChunkInflater inflater, uint width, uint height)
-			{
-				this.inflater = inflater;
-				this.row = 0;
-				this.height = (int)height;
-				this.width = (int)width;
-				
-				buffer = new byte [width * height];
-
-				Fill ();
-			}
+		private static byte [] magic = new byte [] { 137, 80, 78, 71, 13, 10, 26, 10 };
 
-			public void Fill () 
-			{
-				for (; row < height; row ++) { 
-					col = inflater.Inflate (buffer, row * width, width);
-					
-					if (col < width) {
-						inflater.Fill ();
-						System.Console.WriteLine ("short read missing {0} {1} {2}", width - col, row, height);
-					}
-				}
-			}
+		void Load (Stream stream) 
+		{
+			byte [] heading = new byte [8];
+			byte [] crc_data = new byte [4];
+			stream.Read (heading, 0, heading.Length);
 			
-			private static byte PaethPredict (byte a, byte b, byte c)
-			{
-				int p = a + b - c;
-				int pa = System.Math.Abs (p - a);
-				int pb = System.Math.Abs (p - b);
-				int pc = System.Math.Abs (p - c);
-				if (pa <= pb && pa <= pc)
-					return a;
-				else if (pb <= pc)
-					return b;
-				else 
-					return c;
-			}
-
-			public void ReconstructRow (int row, int channels)
-			{
-				int offset = row * width;
-				FilterType type = (FilterType) buffer [offset];
-				byte a = 0;
-				byte x;
-				byte b;
-				byte c = 0;
-				
-				offset++;
-				//buffer [offset++] = 0;
+			for (int i = 0; i < heading.Length; i++)
+			if (heading [i] != magic [i])
+				throw new System.Exception ("Invalid PNG magic number");
+			
+			chunk_list = new System.Collections.ArrayList ();
+			
+			for (int i = 0; stream.Read (heading, 0, heading.Length) == heading.Length; i++) {
+				uint length = BitConverter.ToUInt32 (heading, 0, false);
+				string name = System.Text.Encoding.ASCII.GetString (heading, 4, 4);
+				byte [] data = new byte [length];
+				if (length > 0)
+					stream.Read (data, 0, data.Length);
 				
-				int prev_line;
-
-				//System.Console.WriteLine ("type = {0}", type);
-				for (int col = 1; col < this.width;  col++) {
-					x = buffer [offset];
-
-					prev_line = offset - width;
-
-					a = col <= channels ? (byte) 0 : (byte) buffer [offset - channels];
-					b = (prev_line) < 0 ? (byte) 0 : (byte) buffer [prev_line];
-					c = (prev_line) < 0 || (col <= channels) ? (byte) 0 : (byte) buffer [prev_line - channels];
-
-#if false
-					switch (type) {
-					case FilterType.None:
-						break;
-					case FilterType.Sub:
-						x = (byte) (x + a);
-						break;
-					case FilterType.Up:
-						x = (byte) (x + b);
-						break;
-					case FilterType.Average:
-						x = (byte) (x + ((a + b) >> 1));
-						break;
-					case FilterType.Paeth:
-						x = (byte) (x + PaethPredict (a, b, c));
-						break;
-					default:					
-						throw new System.Exception (System.String.Format ("Invalid FilterType {0}", type));
-					}
-#else
-					if (type == FilterType.Sub) {
-						x = (byte) (x + a);
-					} else if (type == FilterType.Up) {
-						x = (byte) (x + b);
-					} else if (type == FilterType.Average) {
-						x = (byte) (x + ((a + b) >> 1));
-					} else if (type == FilterType.Paeth) {
-						int p = a + b - c;
-						int pa = System.Math.Abs (p - a);
-						int pb = System.Math.Abs (p - b);
-						int pc = System.Math.Abs (p - c);
-						if (pa <= pb && pa <= pc)
-							x = (byte)(x + a);
-						else if (pb <= pc)
-							x = (byte)(x + b);
-						else 
-							x = (byte)(x + c);
-					}
-#endif
-					//System.Console.Write ("{0}.", x);
-					buffer [offset ++] = x;
-				}
-
-			}
-
-			public unsafe void UnpackRGBIndexedLine (Gdk.Pixbuf dest, int line, int depth, byte [] palette, byte [] alpha)
-			{
-				int pos = line * width + 1;
-				byte * pixels = (byte *) dest.Pixels;
+				stream.Read (crc_data, 0, 4);
+				uint crc = BitConverter.ToUInt32 (crc_data, 0, false);
 				
-				pixels += line * dest.Rowstride;
-				int channels = dest.NChannels;
-				int div = (8 / depth);
-				byte mask = (byte)(0xff >> (8 - depth));
-
-				for (int i = 0; i < dest.Width; i++) {
-					int val = buffer [pos + i / div];
-					int shift = (8 - depth) - (i % div) * depth;
-
-					val = (byte) ((val & (byte)(mask << shift)) >> shift);
-
-					pixels [i * channels] = palette [val * 3];
-					pixels [i * channels + 1] = palette [val * 3 + 1];
-					pixels [i * channels + 2] = palette [val * 3 + 2];
-
-					if (channels > 3 && alpha != null) 
-						pixels [i * channels + 3] = val < alpha.Length ? alpha [val] : (byte)0xff; 
-				}
-			}
-
-			public unsafe void UnpackRGB16Line (Gdk.Pixbuf dest, int line, int channels)
-			{
-				int pos = line * width + 1;
-				byte * pixels = (byte *) dest.Pixels;
+				Chunk chunk = Chunk.Generate (name, data);
+				if (! chunk.CheckCrc (crc))
+					throw new System.Exception ("chunk crc check failed");
 				
-				pixels += line * dest.Rowstride;
+				//System.Console.Write ("read one {0} {1}", chunk, chunk.Name);
+				chunk_list.Add (chunk);
 				
-				if (dest.NChannels != channels)
-					throw new System.Exception ("bad pixbuf format");
-
-				int i = 0;
-				int length = dest.Width * channels;
-				while (i < length) {
-					pixels [i++] = (byte) (BitConverter.ToUInt16 (buffer, pos, false) >> 8);
-					pos += 2;
+#if false		       
+				if (chunk is TextChunk) {
+					TextChunk text = (TextChunk) chunk;
+					System.Console.Write (" Text Chunk {0} {1}", 
+							      text.Keyword, "", "");
 				}
-
-			}
-
-			public unsafe void UnpackRGB8Line (Gdk.Pixbuf dest, int line, int channels)
-			{
-				int pos = line * width + 1;
-				byte * pixels = (byte *) dest.Pixels;
-
-				pixels += line * dest.Rowstride;
-				if (dest.NChannels != channels)
-					throw new System.Exception ("bad pixbuf format");
-
-				System.Runtime.InteropServices.Marshal.Copy (buffer, pos, 
-									     (System.IntPtr)pixels, dest.Width * channels);
-
-			}
-
-			public unsafe void UnpackGrayLine (Gdk.Pixbuf dest, int line, int depth, bool alpha)
-			{
-				int pos = line * width + 1;
-				byte * pixels = (byte *) dest.Pixels;
-				
-				pixels += line * dest.Rowstride;
-				int div = (8 / depth);
-				byte mask = (byte)(0xff >> (8 - depth));
-				int length = dest.Width * (alpha ? 2 : 1);
 				
-				for (int i = 0; i < length; i++) {
-					byte val = buffer [pos + i / div];
-					int shift = (8 - depth) - (i % div) * depth;
-
-					if (depth != 8) {
-						val = (byte) ((val & (byte)(mask << shift)) >> shift);
-						val = (byte) (((val * 0xff) + (mask >> 1)) / mask); 
-					}
-					
-					if (!alpha || i % 2 == 0) {
-						pixels [0] = val;
-						pixels [1] = val;
-						pixels [2] = val;
-						pixels += 3;
-					} else {
-						pixels [0] = val;
-						pixels ++;
-					}
-				}
-			}
+				TimeChunk time = chunk as TimeChunk;
+				if (time != null)
+					System.Console.Write(" Time {0}", time.Time);
 
-			public unsafe void UnpackGray16Line (Gdk.Pixbuf dest, int line, bool alpha)
-			{
-				int pos = line * width + 1;
-				byte * pixels = (byte *) dest.Pixels;
-
-				pixels += line * dest.Rowstride;
-
-				int i = 0;
-				while (i < dest.Width) {
-					byte val = (byte) (BitConverter.ToUInt16 (buffer, pos, false) >> 8);
-					pixels [0] = val;
-					pixels [1] = val;
-					pixels [2] = val;
-					if (alpha) {
-						pos += 2;
-						pixels [3] = (byte)(BitConverter.ToUInt16 (buffer, pos, false) >> 8);
-					}
-					pos += 2;
-					pixels += dest.NChannels;
-					i++;
-				}
-			}
-
-			
-		}
-		
-		public Gdk.Pixbuf GetPixbuf ()
-		{
-			ChunkInflater ci = new ChunkInflater ();
-			Chunk palette = null;
-			Chunk transparent = null;
-
-			foreach (Chunk chunk in Chunks) {
-				if (chunk.Name == "IDAT")
-					ci.Add (chunk);
-				else if (chunk.Name == "PLTE") 
-					palette = chunk;
-				else if (chunk.Name == "tRNS")
-					transparent = chunk;
-			}
-
-			IhdrChunk ihdr = (IhdrChunk) Chunks [0];
-			System.Console.WriteLine ("Attempting to to inflate photo {0}.{1}({2}, {3})", ihdr.Color, ihdr.Depth, ihdr.Width, ihdr.Height);
-			ScanlineDecoder decoder = new ScanlineDecoder (ci, ihdr.GetScanlineLength (0), ihdr.Height);
-			decoder.Fill ();
-			//Gdk.Pixbuf pixbuf = decoder.GetPixbuf ();
-
-			//System.Console.WriteLine ("XXXXXXXXXXXXXXXXXXXXXXXXXXX Inflate ############################");
-
-			bool alpha = (ihdr.Color == ColorType.GrayAlpha || ihdr.Color == ColorType.RgbA || transparent != null);
-
-			Gdk.Pixbuf pixbuf = new Gdk.Pixbuf (Gdk.Colorspace.Rgb, 
-							    alpha, 8, (int)ihdr.Width, (int)ihdr.Height);
-			
-			for (int line = 0; line < ihdr.Height; line++) {
-				switch (ihdr.Color) {
-				case ColorType.Rgb:
-					if (ihdr.Depth == 16) {
-						decoder.ReconstructRow (line, 6);
-						decoder.UnpackRGB16Line (pixbuf, line, 3);
-					} else {
-						decoder.ReconstructRow (line, 3);
-						decoder.UnpackRGB8Line (pixbuf, line, 3);
-					}
-					break;
-				case ColorType.RgbA:
-					if (ihdr.Depth == 16) {
-						decoder.ReconstructRow (line, 8);
-						decoder.UnpackRGB16Line (pixbuf, line, 4);						
-					} else {
-						decoder.ReconstructRow (line, 4);
-						decoder.UnpackRGB8Line (pixbuf, line, 4);
-					}
-					break;
-				case ColorType.GrayAlpha:
-					switch (ihdr.Depth) {
-					case 16:
-						decoder.ReconstructRow (line, 4);
-						decoder.UnpackGray16Line (pixbuf, line, true);
-						break;
-					default:
-						decoder.ReconstructRow (line, 2);
-						decoder.UnpackGrayLine (pixbuf, line, ihdr.Depth, true);
-						break;
-					}
-					break;
-				case ColorType.Gray:
-					switch (ihdr.Depth) {
-					case 16:
-						decoder.ReconstructRow (line, 2);
-						decoder.UnpackGray16Line (pixbuf, line, false);
-						break;
-					default:
-						decoder.ReconstructRow (line, 1);
-						decoder.UnpackGrayLine (pixbuf, line, ihdr.Depth, false);
-						break;
-					}
-					break;
-				case ColorType.Indexed:
-					decoder.ReconstructRow (line, 1);
-					decoder.UnpackRGBIndexedLine (pixbuf, 
-								      line, 
-								      ihdr.Depth, 
-								      palette.Data, 
-								      transparent != null ? transparent.Data : null);
-					break;
-				default:
-					throw new System.Exception (System.String.Format ("unhandled color type {0}", ihdr.Color));
-				}
-			}
-			return pixbuf;
-		}
-
-		private static byte [] magic = new byte [] { 137, 80, 78, 71, 13, 10, 26, 10 };
-
-				
-		public class PngHeader {
-			ArrayList chunk_list;
-			
-			public ArrayList Chunks { 
-				get { return chunk_list; }
-			}
-			
-			public PngHeader (Stream stream) 
-			{
-				byte [] heading = new byte [8];
-				byte [] crc_data = new byte [4];
-				stream.Read (heading, 0, heading.Length);
-				
-				for (int i = 0; i < heading.Length; i++)
-				if (heading [i] != magic [i])
-					throw new System.Exception ("Invalid PNG magic number");
-				
-				chunk_list = new System.Collections.ArrayList ();
-				
-				for (int i = 0; stream.Read (heading, 0, heading.Length) == heading.Length; i++) {
-					uint length = BitConverter.ToUInt32 (heading, 0, false);
-					string name = System.Text.Encoding.ASCII.GetString (heading, 4, 4);
-					byte [] data = new byte [length];
-					if (length > 0)
-						stream.Read (data, 0, data.Length);
-					
-					stream.Read (crc_data, 0, 4);
-					uint crc = BitConverter.ToUInt32 (crc_data, 0, false);
-					
-					Chunk chunk = Chunk.Generate (name, data);
-					if (! chunk.CheckCrc (crc))
-						throw new System.Exception ("chunk crc check failed");
-					
-					//System.Console.Write ("read one {0} {1}", chunk, chunk.Name);
-					chunk_list.Add (chunk);
-					
-#if false			       
-					if (chunk is TextChunk) {
-						TextChunk text = (TextChunk) chunk;
-						System.Console.Write (" Text Chunk {0} {1}", 
-								      text.Keyword, "", "");
-					}
-					
-					TimeChunk time = chunk as TimeChunk;
-					if (time != null)
-						System.Console.Write(" Time {0}", time.Time);
-
-					System.Console.WriteLine ("");
+				System.Console.WriteLine ("");
 #endif
-					
-					if (chunk.Name == "IEND")
-						break;
-				}
-			}
-
-			internal string LookupText (string keyword)
-			{
-				TextChunk chunk = LookupTextChunk (keyword);
-				if (chunk != null)
-					return chunk.Text;
-
-				return null;
-			}
-			
-			internal TextChunk LookupTextChunk (string keyword)
-			{
-				foreach (Chunk chunk in Chunks) {
-					TextChunk text = chunk as TextChunk;
-					if (text != null && text.Keyword == keyword)
-						return text;
-				}
-				return null;	
-			}
-			
-			internal void Insert (Chunk chunk)
-			{
-				// FIXME The point of this function is to enforce ordering constraints
-				// it obviously isn't complete right now.
-				if (chunk is IhdrChunk)
-				Chunks.Insert (0, chunk);
-				else if (chunk is TextChunk)
-					Chunks.Insert (1, chunk);
-				else
-					throw new System.Exception ("Uknown ordering for chunk");
-			}
-			
-			public void Save (System.IO.Stream stream)
-			{
-				stream.Write (magic, 0, magic.Length);
-				foreach (Chunk chunk in Chunks) {
-					chunk.Save (stream);
-				}
-			}
-		}
-
-
-		public void Save (System.IO.Stream stream)
-		{
-			Header.Save (stream);
-		}
-
-		public void Save (string path)
-		{
-			string  temp_path = path + ".tmp.png";
-			using (System.IO.Stream output = System.IO.File.OpenWrite (temp_path)) {
-				Save (output);
-			}
-			if (FSpot.Unix.Rename (temp_path, path) < 0) {
-				System.IO.File.Delete (temp_path);
-				throw new System.Exception (System.String.Format ("Unable to rename {0} to {1}", temp_path, path));
+				
+				if (chunk.Name == "IEND")
+					break;
 			}
 		}
 
-		public override void Save (Gdk.Pixbuf pixbuf, System.IO.Stream stream)
+		internal string LookupText (string keyword)
 		{
-			byte [] buffer = PixbufUtils.Save (pixbuf, "png", null, null);
-			MemoryStream mem = new MemoryStream (buffer);
-			PngHeader converted = new PngHeader (mem);
-
-			/* FIXME we need to update the XMP metadata here */
-			foreach (Chunk c in Chunks) {
-				if (c is TextChunk) {
-					converted.Insert (c);
-				}
-			}
+			TextChunk chunk = LookupTextChunk (keyword);
+			if (chunk != null)
+				return chunk.Text;
 
-			converted.Save (stream);
+			return null;
 		}
-
-		public override Cms.Profile GetProfile ()
+			
+		internal TextChunk LookupTextChunk (string keyword)
 		{
-			ColorChunk color = null;
-			IccpChunk icc = null;
-			GammaChunk gamma = null;
-			StandardRgbChunk srgb = null;
-			double gamma_value = 2.2;
-			ColorCIExyY red = new ColorCIExyY (0.64, 0.33, 1.0);
-			ColorCIExyY green = new ColorCIExyY (0.3, 0.6, 1.0);
-			ColorCIExyY blue = new ColorCIExyY (0.15, 0.06, 1.0);
-			ColorCIExyY whitepoint = new ColorCIExyY (0.3127, 0.329, 1.0);
-			ColorCIExyYTriple chroma = new ColorCIExyYTriple (red, green, blue);
-
-			System.Console.WriteLine ("Trying to get profile");
-
 			foreach (Chunk chunk in Chunks) {
-				if (color == null) 
-					color = chunk as ColorChunk;
-				if (icc == null)
-					icc = chunk as IccpChunk;
-				if (srgb == null)
-					srgb = chunk as StandardRgbChunk;
-				if (gamma == null)
-					gamma = chunk as GammaChunk;
-			}
-			
-			System.Console.WriteLine ("color: {0} icc: {1} srgb: {2} gamma: {3}", color, icc, srgb, gamma);
-
-			if (icc != null) {
-				try {
-					return new Profile (icc.Profile);
-				} catch (System.Exception ex) {
-					System.Console.WriteLine ("Error trying to decode embedded profile" + ex.ToString ());
-				}
-			}
-
-			if (srgb != null)
-				return Profile.CreateStandardRgb ();
-
-			if (gamma != null)
-				gamma_value = 1 / gamma.Gamma;
-			
-			if (color != null) {
-				whitepoint = new ColorCIExyY (color.WhiteX.Value, color.WhiteY.Value, 1.0);
-				red = new ColorCIExyY (color.RedX.Value, color.RedY.Value, 1.0);
-				green = new ColorCIExyY (color.GreenX.Value, color.GreenY.Value, 1.0);
-				blue = new ColorCIExyY (color.BlueX.Value, color.BlueY.Value, 1.0);
-				chroma = new ColorCIExyYTriple (red, green, blue);
-			}
-
-			if (color != null || gamma != null) {
-				GammaTable table = new GammaTable (1024, gamma_value);
-				return new Profile (whitepoint, chroma, new GammaTable [] {table, table, table});
+				TextChunk text = chunk as TextChunk;
+				if (text != null && text.Keyword == keyword)
+					return text;
 			}
-			
-			return null;
+			return null;	
 		}
 
-		public override string Description {
+		public string Description {
 			get {
-				string description = Header.LookupText ("Description");
+				string description = LookupText ("Description");
 
 				if (description != null)
 					return description;
 				else
-					return Header.LookupText ("Comment");
+					return LookupText ("Comment");
 			}
 		}
 
-		public void SetDescription (string description) 
-		{
-			TextChunk text = null;
-			text = Header.LookupTextChunk ("Description");
-			
-			if (text != null)
-				text.SetText (description);
-			else 
-				Header.Insert (new TextChunk ("Description", description));
-		}
-
-		public XmpFile GetXmp ()
+		public Xmp.XmpFile GetXmp ()
 		{
-			TextChunk xmpchunk  = Header.LookupTextChunk ("XML:com.adobe.xmp");
+			TextChunk xmpchunk  = LookupTextChunk ("XML:com.adobe.xmp");
 			if (xmpchunk == null)
-				xmpchunk = Header.LookupTextChunk ("XMP");
+				xmpchunk = LookupTextChunk ("XMP");
 
 			if (xmpchunk == null)
 				return null;
 			
 			using (MemoryStream stream = new MemoryStream (xmpchunk.TextData)) {
-				return new XmpFile (stream);
+				return new Xmp.XmpFile (stream);
 			}
 		}
 
-		public void SetXmp (XmpFile xmp)
-		{
-			TextChunk text = null;
-
-			text = Header.LookupTextChunk ("XML:com.adobe.xmp");
-			if (text != null)
-				Chunks.Remove (text);
-			
-			text = Header.LookupTextChunk ("XMP");
-			if (text != null)
-				Chunks.Remove (text);
-
-			ItxtChunk itext = new ItxtChunk ("XML:com.adobe.xmp", "en", false);
-			MemoryStream stream = new MemoryStream ();
-			xmp.Save (stream);
-			itext.SetText (stream.ToArray ());
-			Header.Insert (itext);
-		}
-
-		public override System.DateTime Date {
+		public System.DateTime Date {
 			get {
 				// FIXME: we should first try parsing the
 				// LookupText ("Creation Time") as a valid date
@@ -1420,7 +964,7 @@ namespace FSpot.Png {
 					if (time != null)
 						return time.Time.ToUniversalTime ();
 				}
-				return base.Date;
+				return DateTime.UtcNow;
 			}
 		}
 		
--- /usr/share/devel/f-spot-0.3.0/src/Tiff.cs	2006-12-16 22:00:35.930000000 -0500
+++ Tiff.cs	2006-12-22 14:58:11.970000000 -0500
@@ -1,9 +1,36 @@
-//#define DEBUG_LOADER
-using FSpot;
+//
+// Tiff.cs
+//
+// Authors:
+//     Larry Ewing <lewing@novell.com>
+//
+//
+// Copyright (C) 2004 - 2006 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
 using SemWeb;
 using System;
 
-namespace FSpot.Tiff {
+namespace Beagle.Util.Tiff {
 
 	// This is primarily to preserve the names from the specification
 	// because they differ from the tiff standard names
@@ -863,23 +890,23 @@ namespace FSpot.Tiff {
 		public void SelectDirectory (ImageDirectory dir, StatementSink sink)
 		{
 			foreach (DirectoryEntry e in dir.Entries) {
-#if DEBUG_LOADER
-				System.Console.WriteLine ("{0}", e.Id);
-#endif
+//#if DEBUG_LOADER
+				System.Console.WriteLine ("=> {0}", e.Id);
+//#endif
 				switch (e.Id) {
 				case TagId.IPTCNAA:
 					System.IO.Stream iptcstream = new System.IO.MemoryStream (e.RawData);
-					FSpot.Iptc.IptcFile iptc = new FSpot.Iptc.IptcFile (iptcstream);
+					Iptc.IptcFile iptc = new Iptc.IptcFile (iptcstream);
 					iptc.Select (sink);
 					break;
 				case TagId.PhotoshopPrivate:
 					System.IO.Stream bimstream = new System.IO.MemoryStream (e.RawData);
-					FSpot.Bim.BimFile bim = new FSpot.Bim.BimFile (bimstream);
+					Bim.BimFile bim = new Bim.BimFile (bimstream);
 					bim.Select (sink);
 					break;
 				case TagId.XMP:
 					System.IO.Stream xmpstream = new System.IO.MemoryStream (e.RawData);
-					FSpot.Xmp.XmpFile xmp = new FSpot.Xmp.XmpFile (xmpstream);
+					Xmp.XmpFile xmp = new Xmp.XmpFile (xmpstream);
 					xmp.Select (sink);
 					break;
 				case TagId.ImageDescription:
@@ -1151,6 +1178,8 @@ namespace FSpot.Tiff {
 			return null;
 		}
 		
+#if false // FIXME: Do we need Cms ?
+
 		public Cms.Profile GetProfile ()
 		{
 			Cms.ColorCIExyY whitepoint = new Cms.ColorCIExyY (0, 0, 0);
@@ -1239,6 +1268,7 @@ namespace FSpot.Tiff {
 			return new Cms.Profile (whitepoint, primaries, transfer);
 		}
 
+#endif
 		public void Dump (string name) 
 		{
 			System.Console.WriteLine ("Starting {0}", name);
@@ -1837,6 +1867,7 @@ namespace FSpot.Tiff {
 	}
 
 
+#if false
 	public class TiffFile : ImageFile, SemWeb.StatementSource {
 		public Header Header;
 
@@ -1995,7 +2026,7 @@ namespace FSpot.Tiff {
 			e = Header.Directory.Lookup (TagId.XMP);
 			if (e != null) {
 				System.IO.Stream xmpstream = new System.IO.MemoryStream (e.RawData);
-				FSpot.Xmp.XmpFile xmp = new FSpot.Xmp.XmpFile (xmpstream);
+				Xmp.XmpFile xmp = new Xmp.XmpFile (xmpstream);
 				xmp.Select (sink);
 			}
 
@@ -2128,5 +2159,6 @@ namespace FSpot.Tiff {
 			return file;
 		}
 	}
+#endif
 }
 
--- /usr/share/devel/f-spot-0.3.0/src/XmpFile.cs	2006-11-16 17:18:50.000000000 -0500
+++ XmpFile.cs	2006-12-22 14:58:30.190000000 -0500
@@ -1,8 +1,37 @@
+//
+// XmpFile.cs
+//
+// Authors:
+//     Larry Ewing <lewing@novell.com>
+//
+//
+// Copyright (C) 2004 - 2006 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
 using System.Xml;
 using System.Collections;
 using SemWeb;
 
-namespace FSpot.Xmp {
+namespace Beagle.Util.Xmp {
 	public class XmpFile : SemWeb.StatementSource, SemWeb.StatementSink
 	{
 		MetadataStore store;
